The following code assumes that the graph is stored as adjacency lists and maintains the following data structures:

queue<int> q;
bool visited[N];
int distance[N];

The queue q contains nodes to be processed in increasing order of their distance.
New nodes are always added to the end of the queue, and the node at the beginning
of the queue is the next node to be processed. The array visited indicates which
nodes the search has already visited, and the array distance will contain the
distances from the starting node to all nodes of the graph. The search can be implemented as follows, starting at node x:

visited[x] = true;
distance[x] = 0;
q.push(x);
while (!q.empty()) {
    int s = q.front(); q.pop();
    // process node s
    for (auto u : adj[s]) {
    if (visited[u]) continue;
    visited[u] = true;
    distance[u] = distance[s]+1;
    q.push(u);
    }
}


Like in depth-first search, the time complexity of breadth-first search is O(n+m where n is the number of nodes and m is the number of edges.